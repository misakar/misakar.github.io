<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <link href="https://cdn.bootcss.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" rel="stylesheet" />
        <link href=/static/css/main.css rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="/pygments.css">
        <title>计算机是如何启动的</title>
    </head>
    <body class='main page'>
        <div class="" style="text-align:center; position:relative;">
            <img src=/static/img/misakar2.jpg width = "180px" height="180px"></img>
            <a class="navbar-brand border border-info" href="http://www.misakar.me" style="margin-left:50px">Misaka.r.Me</a>
        </div>
        <hr>
        <div class="container">
            <h1>计算机是如何启动的</h1>
<hr>

<blockquote>
<p>这篇博客以BootLoader代码为例, 具体介绍了计算机的启动流程.
旧博客(纯文字描述)见</p>
</blockquote>
<hr>

<h2>开机!</h2>
<p>想必阅读这篇博客的同学都打开过计算机:-), 按下主机上的电源键, 我们便可进入~~Windows或者~~(删除语法还没支持,那就手动删除!)Linux桌面. 但是这个过程究竟是怎样的? 从计算机启动到加载操作系统究竟执行了哪些代码? 做了哪些工作? 这篇博客将以一个<a href="https://github.com/UiharuOS/uiharu/tree/master/boot_loader">实际的OS代码</a>为例, 介绍计算机的启动过程.</p>
<h2>BootLoader</h2>
<p>BootLoader分为两大过程, <strong><code>Boot</code></strong>和<strong><code>Loader</code></strong>, Boot负责计算机启动初始化(BIOS)和加载MBR到内存, Loader则负责加载操作系统内核. <br/>
这篇博客会分解这两个核心流程, 说明每个部分需要解决的问题并给出相应代码.</p>
<h2>先有鸡还是先有蛋?</h2>
<p>究竟是先有<code>计算机</code>还是先有<code>程序</code>? 计算机的启动需要执行程序、程序的运行离不开计算机环境, 这是一个先有鸡还是先有蛋的问题, 所以计算机的启动过程也被形象的称为<code>bootstrap</code>--用鞋带把自己提起来. <br/> 
程序需要加载到内存中执行, 内存分为两大类: <code>ROM</code>和<code>RAM</code>, RAM内存是我们通常执行程序的地方, 一旦关机, 内存中的数据就会被擦除; 而ROM内存是Read Only Memory, 断电后数据会被保留. <code>考虑到BIOS程序是固定的流程, 可以固化到主板上的ROM芯片上</code>, 这样每次计算机开机时就可以读取BIOS程序, 执行Boot流程.<br/>
如此, 便解决了先有鸡还是先有蛋的问题.</p>
<h2>开始的开始, 我们都是~寄存器</h2>
<p>BIOS程序被固化到ROM芯片上, 计算机可以通过地址总线寻址并执行BIOS程序, BIOS程序所在的地址会被初始化到CS:IP寄存器. 查阅<a href="https://github.com/xem/minix86"><code>IA-32 Intel Architecture Software Developer ’s Manual</code></a>:</p>
<p><img alt="IA-32-Table-9" src="https://user-images.githubusercontent.com/10671733/35482863-dff9ea5a-0475-11e8-8c07-4fb365bf576f.png" /></p>
<p>可以看到CS(代码段寄存器)的基址Base为<code>0xFFFF0000</code>, EIP(指令指针寄存器)的初值为<code>0x0000FFF0</code>, CPU一开始运行在实模式下: <code>CS_Base + EIP = 0xFFFFFFF0</code>, 这个地址就是BIOS所在ROM的地址. </p>
<h2>BIOS</h2>
<p>计算机接通电源后, 初始化各寄存器, 读取固化到ROM芯片上的BIOS(Basic Input Output System)程序。首先计算机会进行硬件带电自检(POST: Power On Self Test), 如果硬件出现问题, 启动终止, 主板发出蜂鸣; 如果一切正常, 屏幕上会显示CPU,内存信息。
初始化和检测完成后, BIOS需要把控制权交给下一阶段启动程序, 这可以在BIOS启动顺序列表中设置, 比如通过U盘安装ubuntu时设置先从U盘启动。<br/>
下面启动<strong><code>bochs虚拟机</code></strong>来演示BIOS阶段:</p>
<p><img alt="bochs-start" src="https://user-images.githubusercontent.com/10671733/35507413-a5cd8b4a-0527-11e8-99f6-df51b9fdfacc.png" /></p>
<p>看到最后一行, 计算机启动后访问的第一个内存地址确实是<code>0x0000FFFFFFF0</code>, 不过有意思的是这段地址并不是直接指向BIOS程序, 而是执行了一个<code>跳转指令: jmpf 0xf000:e05b</code>, 所以根据实际实验结果修正上段的结论: <code>0xFFFFFFF0只是BIOS程序的入口地址, BIOS程序所在的ROM地址是0xfe05b</code>.</p>
<h2>实模式</h2>
<p>鉴于出现了地址计算, 这里暂时离开启动流程, 简单的介绍一下<code>CPU实模式下的内存寻址</code>. <br>
计算机通电后, CPU处于实模式运行, <code>内存地址=段基址:段内偏移地址</code>, 即<code>内存地址=代码段寄存器(CS)的值左移4位+指令指针寄存器(IP)的值</code>. 在不跨段的情况下, CPU以当前IP值+当前指令的机器码长度更新IP寄存器, 再到新的IP值处读取指令并执行; 如果下一条指令需要跨段访问, 则加载新的段基址到CS寄存器. 如此往复, CPU通过CS:IP实现取址、执行的循环. <br>
所以<code>jmpf 0xf000:e05b</code>跳转到的地址就是<code>0xf000 &lt;&lt; 4 + 0xe05b = 0xf0000 + 0xe05b = 0xfe05b</code>. <br/>
CPU在实模式下地址总线20位, 最多可访问:<code>2^20Byte = 1MB</code>内存.</p>
<h2>MBR</h2>
<p>如果继续运行bochs, 会发生报错: <code>[BIOS ] No bootable device</code>
<img alt="bootable" src="https://user-images.githubusercontent.com/10671733/35511510-2af3bf24-0537-11e8-927a-ef57826e6fd4.png" />
要想知道报错的原因, 就需要知道BIOS是如何加载可启动设备的(bootable device, 如硬盘、U盘等).<br/>
BIOS会检查配置顺序中的第一个启动设备上的<code>第一个扇区</code>, 这个扇区也被称为主引导扇区, 主引导扇区上的512字节程序就是Master Boot Record(MBR). 因为此时bochs的虚拟硬盘(默认配置bochs从硬盘启动)还没有写入MBR程序, 所以这里就报错了. <br/>
BIOS检查0盘0道1扇区最后两个字节是不是0xaa55(魔数), 若是, 证明是有效的MBR程序, <a href="http://www.ruanyifeng.com/blog/2015/09/0x7c00.html">便将MBR加载到内存的<code>0x7c00</code>处</a>. <br/>
下面来具体分析MBR的作用: <br/></p>
<h2>为什么不把引导功能集成到BIOS中?</h2>
<h2>Loader</h2>
<h2>内核映像</h2>
        </div>
<div id="bootpre">
    <script>
        var x = document.getElementsByClassName("codehilite");
        for (var i = 0; i < x.length; i++)
        {
            x[i].childNodes[0].className = "border border-danger";
        }
    </script>
</div>
<div id="h1center">
    <script>
        var x = document.getElementsByTagName("h1")[0].style="text-align:center";
    </script>
</div>
<div id="_blank">
    <script>
        var as = document.getElementsByTagName('a');
        // alert(as[1]);
        for (var i = 1; i < as.length; i++) {
            // as[i].style="target: _blank";
            as[i].setAttribute('target', '_blank');
        }
    </script>
</div>
<div id="disqus_thread"></div>
<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://neo1218flask.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </body>
</html>